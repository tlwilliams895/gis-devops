<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Networking Between Containers &#8212; LaunchCode: GIS DevOps  documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/fa/css/all.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/launchcode.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="prev" title="Docker" href="index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html"><span><img src="../../_static/lc-ed-logo.png" alt="LaunchCode logo"></span>
          GIS DevOps</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="/installations/index.html">Installations</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Pages <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ol>
<li class="toctree-l1"><a class="reference internal" href="../../week01/day1/index.html">Week 1 - Day 1: Welcome, Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week01/day2/index.html">Week 1 - Day 2: Terminal, Shell, Git</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week01/day3/index.html">Week 1 - Day 3: Shell, Git, SQL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week01/day4/index.html">Week 1 - Day 4: SQL, HTTP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week01/day5/index.html">Week 1 - Day 5: HTTP, Docker</a></li>
</ol>
<ol>
<li class="toctree-l1"><a class="reference internal" href="../../week02/day1/index.html">Week 2 - Day 1: HTML, CSS, Browser DevTools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week02/day2/index.html">Week 2 - Day 2: HTML/CSS Template, JavaScript Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week02/day3/index.html">Week 2 - Day 3: Programming Fundamentals, JavaScript, DOM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week02/day4/index.html">Week 2 - Day 4: JS, DOM, Promises, AJAX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week02/day5/index.html">Week 2 - Day 5: Promises, AJAX, HTTP</a></li>
</ol>
<ol>
<li class="toctree-l1"><a class="reference internal" href="../../week03/day1/index.html">Week 3 - Day 1: Java, OOP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week03/day2/index.html">Week 3 - Day 2: Spring Boot, Controllers, Routes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week03/day3/index.html">Week 3 - Day 3: Models, ORM (Hibernate)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week03/day4/index.html">Week 3 - Day 4: Persistence, ORM Relationships</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week03/day5/index.html">Week 3 - Day 5: Review</a></li>
</ol>
<ol>
<li class="toctree-l1"><a class="reference internal" href="../../week04/day1/index.html">Week 4 - Day 1: Git, GitLab, IntelliJ, Refactoring, Unit Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week04/day2/index.html">Week 4 - Day 2: Security, Test-driven development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week04/day3/index.html">Week 4 - Day 3: Integration testing, dependency injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week04/day4/index.html">Week 4 - Day 4: Postgres, Spring Data, JPA, Hibernate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week04/day5/index.html">Week 4 - Day 5: AJAX, Open Layers</a></li>
</ol>
<ol>
<li class="toctree-l1"><a class="reference internal" href="../../week05/project/index.html">Week 5 - Project Week: Zika Mission Control</a></li>
</ol>
<ol>
<li class="toctree-l1"><a class="reference internal" href="../../week06/day1/index.html">Week 6 - Day 1: RESTful web services</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week06/day2/index.html">Week 6 - Day 2: Swagger REST framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week06/day3/index.html">Week 6 - Day 3: Intro to Elasticsearch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week06/day4/index.html">Week 6 - Day 4: More Elasticsearch, Integrating ES with Spring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week06/day5/index.html">Week 6 - Day 5: ES2015, ESLint, OpenLayers</a></li>
</ol>
<ol>
<li class="toctree-l1"><a class="reference internal" href="../../week07/project/index.html">Week 7 - Project Week: Zika Mission Control Part 2</a></li>
</ol>
<ol>
<li class="toctree-l1"><a class="reference internal" href="../../week08/day1/index.html">Week 8 - Day 1: Intro to DevOps/AWS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week08/day2/index.html">Week 8 - Day 2: More with AWS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week08/day3/index.html">Week 8 - Day 3: 12 Factor Apps and Auto Scaling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week08/day4/index.html">Week 8 - Day 4: Gradle, Continuous Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week08/day5/index.html">Week 8 - Day 5: Sonarqube</a></li>
</ol>
<ol>
<li class="toctree-l1"><a class="reference internal" href="../../week09/project/index.html">Week 9 - Project Week: Zika Mission Control Part 3</a></li>
</ol>
<ol>
<li class="toctree-l1"><a class="reference internal" href="../../week11/project/index.html">Week 11 - Project Week: Zika Mission Control Part 4</a></li>
</ol>
<ol>
<li class="toctree-l1"><a class="reference internal" href="../../week12/day3/index.html">Week 12 - Day 3: Intro to Docker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week12/day4/index.html">Week 12 - Day 4: OAuth 2.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../week12/day5/index.html">Week 12 - Day 5: Certificates</a></li>
</ol>
<ol>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/aws-intro/index.html">Walkthrough: Intro to AWS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/aws-rds-vpc/index.html">Walkthrough: Introduction to Amazon Web Services</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/certificate-authority/index.html">Certificate Authority</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/client-certificates/index.html">Client Certificates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/docker/index.html">Walkthrough: Intro to Docker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/elasticsearch-spring/index.html">Walkthrough: Elasticsearch in Spring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/elasticsearch/index.html">Walkthrough: Elasticsearch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/elasticsearch2/index.html">Walkthrough: Elasticsearch Part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/eslint-airwaze/index.html">Walkthrough: ESLint Airwaze</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/gitLab/index.html">Walkthrough: Git and Gitlab</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/gradle/index.html">Walkthrough: Gradle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/hashing-salting/index.html">Walkthrough: Hashing and Salting Passwords</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/jenkins/index.html">Walkthrough: CI/CD With Jenkins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/launchcart-rest/index.html">Walkthrough: LaunchCart REST</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/oauth2/index.html">Visual OAuth</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/openlayers/index.html">Walkthrough: OpenLayers and jQuery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/postgress/index.html">Walkthrough: PostgreSQL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/sonarqube/index.html">Walkthrough: Sonarqube</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/spring-data-jpa-hibernate/index.html">Walkthrough: Cars Demo - Spring Data, JPA, Hibernate</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/spring-integration-testing/index.html">Walkthrough: Spring Integration Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/swagger/index.html">Walkthrough: SwaggerUI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/tdd/index.html">Walkthrough: TDD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/unit-tests/index.html">Walkthrough: Unit Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../walkthroughs/upgrading-spring-boot/index.html">Walkthrough: Upgrading to Spring Boot 2.x</a></li>
</ol>
<ol>
<li class="toctree-l1"><a class="reference internal" href="../../installations/00-prep-week/index.html">Installation: Essential Tooling &amp; Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installations/01-docker/index.html">Installation: Docker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installations/02-docker-psql/index.html">Installation: Docker PSQL Container</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installations/03-docker-postgis/index.html">Installation: Docker PostGIS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installations/04-docker-elasticsearch/index.html">Installation: Docker Elasticsearch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installations/05-docker-kibana/index.html">Installation: Docker Kibana</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installations/06-docker-jenkins/index.html">Installation: Docker Jenkins</a></li>
</ol>
<ol>
<li class="toctree-l1"><a class="reference internal" href="../../configurations/00-intellij/index.html">Configuration: IntelliJ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../configurations/01-runtime-configurations/index.html">Configuration: IntelliJ - Runtime Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../configurations/02-environment-variables-intellij/index.html">Configuration: Environment Variables - IntelliJ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../configurations/04-spring-elasticsearch/index.html">Configuration: Spring &amp; Elasticsearch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../configurations/05-spring-postgres/index.html">Configuration: Spring &amp; Postgres</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../configurations/06-vscode-eslint/index.html">Configuration: Visual Studio Code - ESLint</a></li>
</ol>
<ol class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Docker</a></li>
</ol>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
    <label for="q" class="searchLabel">Search</label>
    <input type="text" name="q" class="form-control" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">Networking Between Containers</a></li>
<li><a class="reference internal" href="#using-the-default-network">Using the Default Network</a></li>
<li><a class="reference internal" href="#using-a-custom-network">Using a Custom Network</a><ul>
<li><a class="reference internal" href="#connecting-containers-on-a-custom-network">Connecting Containers On a Custom Network</a></li>
<li><a class="reference internal" href="#two-containers-and-a-network">Two Containers and a Network</a></li>
<li><a class="reference internal" href="#custom-network-example">Custom Network Example</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="col-md-9 content">
      
  <div class="section" id="networking-between-containers">
<span id="docker-networking"></span><h1>Networking Between Containers<a class="headerlink" href="#networking-between-containers" title="Permalink to this headline">¶</a></h1>
<p>So far we have learned how to run containers, like our PostGIS database, which we have used for local development and testing. We have been connecting to this database using <code class="docutils literal notranslate"><span class="pre">localhost</span></code> and <code class="docutils literal notranslate"><span class="pre">5432</span></code>, the <strong>published port</strong> of the container.</p>
<p>You are able to connect to your published containers through <code class="docutils literal notranslate"><span class="pre">localhost:PORT</span></code> because that process “originates” from the local machine itself. Technically the process originates from a container. But we publish, or bind, a host port to a container with <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span> <span class="pre">-p</span> <span class="pre">&lt;host&gt;:&lt;container&gt;</span></code>. From that point onward any connections made on the [local] host machine’s port will be forwarded to the published container.</p>
<div class="admonition">
<p class="first admonition-title"><i class="fas fa-sticky-note" aria-hidden="true"></i>Note</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">localhost</span></code> is a <strong>hostname</strong> for a machine relative to a process it is running. Like any other hostname it is used to identify a machine on a network without having to rely on a fixed IP address thanks to DNS resolution. <code class="docutils literal notranslate"><span class="pre">localhost</span></code> is resolved to the <em>home</em> IP address <code class="docutils literal notranslate"><span class="pre">127.0.0.1</span></code> of <em>that machine</em> using a special mechanism called a <a class="reference external" href="https://www.hostinger.com/tutorials/what-is-localhost" target="_blank">loopback<i class="fas fa-external-link-alt" aria-hidden="true"></i></a>. In simple terms the loopback was made for simulating networking from within a single machine. This is really useful for us when we are developing applications locally!</p>
</div>
<div class="admonition">
<p class="first admonition-title"><i class="fas fa-lightbulb" aria-hidden="true"></i>Tip</p>
<p class="last">You can’t use <code class="docutils literal notranslate"><span class="pre">localhost</span></code> in a container to network with anything but processes running <strong>inside it</strong>. Because containers behave like their own machines so <code class="docutils literal notranslate"><span class="pre">localhost</span></code> refers to their <em>own machine</em> that runs their respective process. Other services (processes) are in <em>their own</em> containers [machines], each with <em>their own</em> <code class="docutils literal notranslate"><span class="pre">localhost</span></code> resolution.</p>
</div>
<p>So how do we connect two or more containers? Generally speaking this is a question about <strong>networking between machines [containers] on a network</strong>. There are three options to consider for networking within the same Docker host:</p>
<ul class="simple">
<li>The simplest, but least reliable, solution is to use the default container network</li>
<li>A less scalable, but more reliable, solution is to use a custom bridge network</li>
<li>A (relatively) more complex, but more scalable and reliable, solution is to use <code class="docutils literal notranslate"><span class="pre">docker-compose</span></code></li>
</ul>
</div>
<div class="section" id="using-the-default-network">
<h1>Using the Default Network<a class="headerlink" href="#using-the-default-network" title="Permalink to this headline">¶</a></h1>
<p>By default all containers are connected to the <code class="docutils literal notranslate"><span class="pre">bridge</span> <span class="pre">network</span></code> when they are created. This network (along with the <code class="docutils literal notranslate"><span class="pre">host</span></code> and <code class="docutils literal notranslate"><span class="pre">none</span></code> networks) are all created automatically when the Docker daemon starts up. Within the <code class="docutils literal notranslate"><span class="pre">bridge</span> <span class="pre">network</span></code> every container is assigned a private (internal) IP address. These addresses are assigned within the <code class="docutils literal notranslate"><span class="pre">bridge</span> <span class="pre">network</span></code>’s subnet[work] range.</p>
<p>Containers can connect to each other using these private IP addresses. In the same way that any two machines on a network can connect to each other by their IP addresses. However, addresses on a network are rarely static.</p>
<p>Typically addresses are dynamically assigned as machines are added and removed from it. Containers behave the same as they are created and destroyed or assigned and unassigned from the default <code class="docutils literal notranslate"><span class="pre">bridge</span> <span class="pre">network</span></code>.</p>
<div class="admonition">
<p class="first admonition-title"><i class="fas fa-exclamation-triangle" aria-hidden="true"></i>Warning</p>
<p class="last"><strong>The addresses assigned to containers on a network will only be constant for as long as the containers exist on the network</strong>. If we “hard-code” the use of one of these IP addresses there is no guarantee that it will be assigned to the same container in the future!</p>
</div>
<p>You can list all of the networks (default and custom) using the following command:</p>
<div class="code bash highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker network ls
</pre></div>
</div>
<p>You can also inspect the details of a network using Docker. This will show you information about the network including with the containers that are assigned to it. You can see the network’s subnet range under <code class="docutils literal notranslate"><span class="pre">IPAM.Config.Subnet</span></code>. Under <code class="docutils literal notranslate"><span class="pre">Containers</span></code> you can see all of the containers connected to the network and their IP addresses (notice how they are all within the subnet range):</p>
<div class="code bash highlight-none notranslate"><div class="highlight"><pre><span></span># inspect a network
$ docker network inspect &lt;network name&gt;

# inspect the default bridge network
$ docker network inspect bridge

# use sed to only show the container information (between Containers and Options sections)
$ docker network inspect bridge | sed -n &#39;/Containers/,/Options/p&#39;
</pre></div>
</div>
<p>To connect one container to another you just use their IP addresses along with the port the container’s process is running on.</p>
<div class="admonition">
<p class="first admonition-title"><i class="fas fa-sticky-note" aria-hidden="true"></i>Note</p>
<p class="last">Containers are completely isolated from the host machine in terms of networking (and file system access) by default. But unless a container is assigned to another network when it is created it will <strong>always join the default</strong> <code class="docutils literal notranslate"><span class="pre">bridge</span> <span class="pre">network</span></code> and be accessible by any other container within it. <strong>Even if the container hasn’t published or exposed its port!</strong></p>
</div>
<p>By far using the default network addresses is the simplest mechanism of networking between containers. It can work great in a pinch. But this simplicity comes at the cost of reliance on unchanging addresses - which is not a practical expectation. In the next approach we will learn how to use hostname <strong>aliases</strong> in a custom network to <em>resolve</em> this dependency on a fixed IP address.</p>
<div class="admonition">
<p class="first admonition-title"><i class="fas fa-sticky-note" aria-hidden="true"></i>Note</p>
<p class="last">Did you spot the pun? You will after reading the custom network approach!</p>
</div>
</div>
<div class="section" id="using-a-custom-network">
<h1>Using a Custom Network<a class="headerlink" href="#using-a-custom-network" title="Permalink to this headline">¶</a></h1>
<p>In the previous section we learned about using hard-coded container IP addresses on the <code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">bridge</span> <span class="pre">network</span></code>. We also learned how using the IP addresses can lead to inconsistent behavior due to the ephemeral nature of containers and, by extension, their assigned addresses within a network.</p>
<p>Fortunately Docker lets us create <em>custom user-defined networks</em> that support networking between containers using aliases, or <strong>hostnames</strong>, instead of their mutable IP addresses. In these custom networks the <strong>aliases remain constant</strong> and are resolved into the IP address the containers are assigned. The hostname resolutions in each network are handled by an internal DNS that Docker manages.</p>
<div class="admonition">
<p class="first admonition-title"><i class="fas fa-sticky-note" aria-hidden="true"></i>Note</p>
<p class="last">Aliases can only be used in custom networks. Within the default <code class="docutils literal notranslate"><span class="pre">bridge</span> <span class="pre">network</span></code> only the assigned IP address can be used to network with other containers.</p>
</div>
<p>Instead of hard-coding an IP address we can refer to a container by its alias and its internal IP will be resolved to the correct address. Even if that address changes in the future. <strong>This is true as long as the container is on the same network and given the same alias.</strong></p>
<div class="admonition">
<p class="first admonition-title"><i class="fas fa-sticky-note" aria-hidden="true"></i>Note</p>
<p class="last">Using an alias for a container’s internal IP address on a network is no different than using <code class="docutils literal notranslate"><span class="pre">localhost</span></code> as an alias for <code class="docutils literal notranslate"><span class="pre">127.0.0.1</span></code> on your laptop. Because <code class="docutils literal notranslate"><span class="pre">localhost</span></code> is just that - the <strong>local host[name]</strong> of your machine!</p>
</div>
<div class="admonition">
<p class="first admonition-title"><i class="fas fa-lightbulb" aria-hidden="true"></i>Tip</p>
<p class="last">Docker networking can be a pretty complicated topic. <a class="reference external" href="https://docs.docker.com/network/" target="_blank">There are a lot of different network types<i class="fas fa-external-link-alt" aria-hidden="true"></i></a> (including custom drivers). Each has pros and cons depending on the context of the system.</p>
</div>
<p>For our purposes we are only concerned with networking between containers <strong>on the same Docker host</strong>. This simplifies things for us. We can use a custom <strong>bridge network</strong> which happens to be the default driver used when issuing the <code class="docutils literal notranslate"><span class="pre">network</span> <span class="pre">create</span></code> command:</p>
<div class="code bash highlight-none notranslate"><div class="highlight"><pre><span></span># create a bridge network by the given name
$ docker network create &lt;network name&gt;

# view all networks (3 defaults and the custom one created above)
$ docker network ls
</pre></div>
</div>
<div class="section" id="connecting-containers-on-a-custom-network">
<h2>Connecting Containers On a Custom Network<a class="headerlink" href="#connecting-containers-on-a-custom-network" title="Permalink to this headline">¶</a></h2>
<p>Once you have created a custom network you can start connecting containers to it. Containers can be added when they are created by using the <code class="docutils literal notranslate"><span class="pre">--network</span> <span class="pre">&lt;network</span> <span class="pre">name&gt;</span></code> option of <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code>. Or they can be added (and removed) after being created using the <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">network</span> <span class="pre">connect/disconnect</span></code> commands.</p>
<div class="admonition">
<p class="first admonition-title"><i class="fas fa-sticky-note" aria-hidden="true"></i>Note</p>
<p class="last">If a container is added to a network <em>after being created</em> it will be connected to both the default <code class="docutils literal notranslate"><span class="pre">bridge</span> <span class="pre">network</span></code> <em>and</em> the new network.</p>
</div>
<p>In a custom network the alias of each container can be:</p>
<ul class="simple">
<li>the container name, assigned using the <code class="docutils literal notranslate"><span class="pre">--name</span></code> option in <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code></li>
<li>the container ID, assigned automatically to all new containers</li>
<li>the service name of a container created through <code class="docutils literal notranslate"><span class="pre">docker-compose</span></code></li>
<li>a custom alias assigned using the <code class="docutils literal notranslate"><span class="pre">--alias</span></code> option in <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">network</span> <span class="pre">connect</span></code></li>
<li>one or more custom aliases using the <code class="docutils literal notranslate"><span class="pre">--network-aliases</span></code> option in <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code></li>
</ul>
<p>Below is a list of useful commands for managing containers and their aliases within a custom network:</p>
<div class="code bash highlight-none notranslate"><div class="highlight"><pre><span></span># connect a container whose hostname will be the container name
$ docker network connect &lt;network name&gt; &lt;container name&gt;

# connect a container with a custom alias
$ docker network connect --alias &lt;custom alias&gt; &lt;network name&gt; &lt;container name&gt;

# disconnect a container
$ docker network disconnect &lt;network name&gt; &lt;container name&gt;

# connect to a custom network (instead of the default bridge) when running a container
$ docker run --network &lt;network name&gt; ...

# connect to a custom network AND give the container alias(es) on that network
$ docker run --network &lt;network name&gt; --network-alias &lt;alias name&gt;[,&lt;other alias name&gt;,...] ...
</pre></div>
</div>
<div class="admonition">
<p class="first admonition-title"><i class="fas fa-lightbulb" aria-hidden="true"></i>Tip</p>
<p class="last">When using a custom network you can replace your intuitive usage of <code class="docutils literal notranslate"><span class="pre">localhost</span></code> with the alias, or hostname, of the container [another machine] you want to connect to.  <strong>As long as both those containers [machines] are on the same network</strong>.</p>
</div>
</div>
<div class="section" id="two-containers-and-a-network">
<h2>Two Containers and a Network<a class="headerlink" href="#two-containers-and-a-network" title="Permalink to this headline">¶</a></h2>
<p>Let’s look at a generalized example using two containers and a custom network. In this example the <code class="docutils literal notranslate"><span class="pre">service-one</span></code> container needs to connect to the <code class="docutils literal notranslate"><span class="pre">service-two</span></code> container:</p>
<div class="code bash highlight-none notranslate"><div class="highlight"><pre><span></span># create the network
$ docker network create my-network

# create the containers and connect them to the network
$ docker run --name service-one --network my-network ...
$ docker run --name service-two --network my-network ...
</pre></div>
</div>
<p>Now within the <code class="docutils literal notranslate"><span class="pre">service-one</span></code> container we can connect to <code class="docutils literal notranslate"><span class="pre">service-two</span></code> by its by its container name <code class="docutils literal notranslate"><span class="pre">service-two</span></code> (instead of <code class="docutils literal notranslate"><span class="pre">localhost</span></code>)! The same is true from <code class="docutils literal notranslate"><span class="pre">service-two</span></code> to <code class="docutils literal notranslate"><span class="pre">service-one</span></code> using the latter’s alias.</p>
<p>You can test how the container name aliases get resolved to their private IP address on the network by issuing a <code class="docutils literal notranslate"><span class="pre">curl</span></code> request from within one of the containers and using the <em>verbose</em> option <code class="docutils literal notranslate"><span class="pre">-v</span></code> to see the connection steps in detail:</p>
<div class="admonition">
<p class="first admonition-title"><i class="fas fa-sticky-note" aria-hidden="true"></i>Note</p>
<p class="last">The container must have <code class="docutils literal notranslate"><span class="pre">curl</span></code> installed to perform this test. Many container’s are slimmed down to only include the programs needed to support their main process and may not have <code class="docutils literal notranslate"><span class="pre">curl</span></code>.</p>
</div>
<div class="code bash highlight-none notranslate"><div class="highlight"><pre><span></span># note the container must have curl installed for this to work!

# the curl -v option prints out connection details
$ docker exec &lt;container name&gt; curl &lt;other container alias&gt;:&lt;port&gt; -v

# you will get an output like this
* TCP_NODELAY set
* Connected to &lt;container alias&gt; (172.X.X.X) port &lt;port&gt; (#0)
&gt; GET / HTTP/1.1
&gt; Host: &lt;alias&gt;:&lt;port&gt;
</pre></div>
</div>
<p>Using curl is a simple example to show how connections are formed. You can see how the container’s hostname is resolved to its IP address on the second line. In practice you will be forming database or service to service connections for more useful business!</p>
<div class="admonition">
<p class="first admonition-title"><i class="fas fa-lightbulb" aria-hidden="true"></i>Tip</p>
<p class="last">The same process can be repeated for any number of containers <strong>as long as the containers are on the same network and you use their aliases to connect</strong>.</p>
</div>
</div>
<div class="section" id="custom-network-example">
<h2>Custom Network Example<a class="headerlink" href="#custom-network-example" title="Permalink to this headline">¶</a></h2>
<p>We will create a basic HTTP server container, <code class="docutils literal notranslate"><span class="pre">server</span></code>, and a container with the <code class="docutils literal notranslate"><span class="pre">curl</span></code> program installed, <code class="docutils literal notranslate"><span class="pre">client</span></code>. The <code class="docutils literal notranslate"><span class="pre">server</span></code> container will serve a file with a message which the <code class="docutils literal notranslate"><span class="pre">client</span></code> container will request using <code class="docutils literal notranslate"><span class="pre">curl</span></code>.</p>
<p>First create the network:</p>
<div class="code bash highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker network create networking-test
</pre></div>
</div>
<p>Now create the message file:</p>
<div class="code bash highlight-none notranslate"><div class="highlight"><pre><span></span># create a temporary directory to mount in the container
$ mkdir /tmp/networking-test

# create the file
$ echo &#39;using container aliases works!&#39; &gt; /tmp/networking-test/message
</pre></div>
</div>
<p>Next let’s run the <code class="docutils literal notranslate"><span class="pre">server</span></code> container. We will be using the <code class="docutils literal notranslate"><span class="pre">launchcodedevops/simple-http</span></code> image for this example. It runs a <code class="docutils literal notranslate"><span class="pre">python</span></code> simple HTTP server process on port <code class="docutils literal notranslate"><span class="pre">8080</span></code>. It serves any files that are in the <code class="docutils literal notranslate"><span class="pre">/var/www/</span></code> directory within the container. We will use a <code class="docutils literal notranslate"><span class="pre">bind</span> <span class="pre">mount</span></code> to mount our temporary directory, in the host machine, onto the serving directory, in the container, so we can access the file from the <code class="docutils literal notranslate"><span class="pre">client</span></code>:</p>
<div class="code bash highlight-none notranslate"><div class="highlight"><pre><span></span># the :ro volume option means &quot;read-only&quot;
$ docker run -d --rm --name server --network networking-test -v /tmp/networking-test/:/var/www/:ro launchcodedevops/simple-http
</pre></div>
</div>
<div class="admonition">
<p class="first admonition-title"><i class="fas fa-lightbulb" aria-hidden="true"></i>Tip</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">--rm</span></code> option will automatically remove a container when it exits or is stopped by the host</p>
</div>
<p>Create the <code class="docutils literal notranslate"><span class="pre">client</span></code> container which is just a basic image with the <code class="docutils literal notranslate"><span class="pre">curl</span></code> program installed. We will use this container to make <code class="docutils literal notranslate"><span class="pre">curl</span></code> requests against the <code class="docutils literal notranslate"><span class="pre">server</span></code> container:</p>
<div class="code bash highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker run -itd --name client --network networking-test launchcodedevops/simple-client
</pre></div>
</div>
<p>Inspect the network to see that both the containers are connected to it. Notice the <code class="docutils literal notranslate"><span class="pre">Containers.Name</span></code> field for the <code class="docutils literal notranslate"><span class="pre">server</span></code> container. This is the hostname <strong>alias</strong> we will use to connect over the custom network:</p>
<div class="code bash highlight-none notranslate"><div class="highlight"><pre><span></span>$ docker network inspect networking-test

# or print just the Containers section using sed
$ docker network inspect networking-test | sed -n &#39;/Containers/,/Options/p&#39;
</pre></div>
</div>
<div class="admonition">
<p class="first admonition-title"><i class="fas fa-sticky-note" aria-hidden="true"></i>Note</p>
<p class="last">Take note of the <code class="docutils literal notranslate"><span class="pre">server</span></code> container’s IP address on the network</p>
</div>
<p>Now let’s use the <code class="docutils literal notranslate"><span class="pre">exec</span></code> command to <em>execute</em> a <code class="docutils literal notranslate"><span class="pre">curl</span></code> request from the <code class="docutils literal notranslate"><span class="pre">client</span></code> container to the <code class="docutils literal notranslate"><span class="pre">server</span></code> container on port <code class="docutils literal notranslate"><span class="pre">8080</span></code>. We will request the <code class="docutils literal notranslate"><span class="pre">message</span></code> file from its serving directory to see if our networking test succeeded…</p>
<div class="code bash highlight-none notranslate"><div class="highlight"><pre><span></span># the -v, verbose, option will show connection data
$ docker exec client curl -v server:8080/message

# output
# we can see how the alias was resolved into the container IP on the network
...
* Connected to server (172.28.0.2) port 8080 (#0)
&gt; GET /message HTTP/1.1
&gt; Host: server:8080
...
&lt;
using container aliases works!
</pre></div>
</div>
<p>Clean up by stopping the containers, remove the network and delete the temporary directory:</p>
<div class="code bash highlight-none notranslate"><div class="highlight"><pre><span></span># once the containers are stopped they will remove themselves automatically
$ docker stop server client

# remove the network
$ docker network remove

# remove the temp directory and file
$ rm -rf /tmp/networking-test
</pre></div>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
    </p>
  </div>
</footer>
  </body>
</html>